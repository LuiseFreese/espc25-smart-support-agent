import { InvocationContext, Timer } from '@azure/functions';
import { GraphService } from '../services/GraphService';
import { TableStorageService } from '../services/TableStorageService';
import { AIService } from '../services/AIService';

export async function CheckMailboxTimer(
  myTimer: Timer,
  context: InvocationContext
): Promise<void> {
  context.log('Timer trigger: Checking mailbox for new emails...');

  if (myTimer.isPastDue) {
    context.log('Timer trigger is running late!');
  }

  try {
    const supportEmail = process.env.SUPPORT_EMAIL_ADDRESS;

    if (!supportEmail) {
      context.log('SUPPORT_EMAIL_ADDRESS not configured. Skipping mailbox check.');
      return;
    }

    const graphService = new GraphService();
    const storageService = new TableStorageService();
    const aiService = new AIService();

    // Get unread emails
    const emails = await graphService.getUnreadEmails();

    if (emails.length === 0) {
      context.log('No unread emails found.');
      return;
    }

    context.log(`Found ${emails.length} unread email(s). Processing...`);

    let successCount = 0;
    let errorCount = 0;

    for (const email of emails) {
      try {
        // Check for duplicate
        const existingTicket = await storageService.findTicketByEmailId(email.id);
        if (existingTicket) {
          context.log(`Email ${email.id} already processed as ticket ${existingTicket.TicketID}, skipping...`);
          await graphService.markAsRead(email.id);
          successCount++;
          continue;
        }

        context.log(`Processing email: ${email.subject}`);

        // Extract and clean email body
        const emailBody = email.body.content.replace(/<[^>]*>/g, '').slice(0, 5000).trim();

        if (!emailBody) {
          context.log(`Email ${email.id} has empty body, skipping...`);
          await graphService.markAsRead(email.id);
          continue;
        }

        // Triage the email
        const triage = await aiService.performTriage(emailBody);

        // Search knowledge base
        const ragResult = await aiService.searchKnowledgeBase(emailBody);

        // Create ticket
        const ticketId = await storageService.createTicket({
          TicketID: '', // Will be generated by createTicket
          Title: email.subject,
          Description: emailBody,
          Category: triage.category,
          Priority: triage.priority,
          Status: ragResult.confidence > 0.7 ? 'Auto-Resolved' : 'Needs Human Review',
          CustomerEmail: email.from.emailAddress.address,
          AIResponse: ragResult.answer,
          Confidence: ragResult.confidence,
          EmailMessageId: email.id
        });

        context.log(`Created ticket ${ticketId} (Category: ${triage.category}, Priority: ${triage.priority}, Confidence: ${ragResult.confidence})`);

        // Send response based on confidence
        if (ragResult.confidence > 0.7) {
          // High confidence - send auto-reply
          await graphService.sendReply(
            email.from.emailAddress.address,
            email.subject,
            ragResult.answer,
            ticketId
          );
          context.log(`Sent auto-reply to ${email.from.emailAddress.address}`);
        } else {
          // Low confidence - forward to support team
          const supportTeamEmail = process.env.SUPPORT_TEAM_EMAIL || email.from.emailAddress.address;
          await graphService.forwardToSupport(
            supportTeamEmail,
            email.subject,
            ticketId,
            triage.category,
            triage.priority,
            ragResult.confidence,
            email.from.emailAddress.address,
            emailBody,
            ragResult.answer
          );
          context.log(`Forwarded to support team for review`);
        }

        // Mark as read
        await graphService.markAsRead(email.id);
        successCount++;

      } catch (emailError: any) {
        context.error(`Error processing email ${email.id}: ${emailError.message}`);
        errorCount++;
      }
    }

    context.log(`Timer completed: ${successCount} emails processed successfully, ${errorCount} errors`);

  } catch (error: any) {
    context.error('Timer trigger failed:', error);
    throw error;
  }
}
